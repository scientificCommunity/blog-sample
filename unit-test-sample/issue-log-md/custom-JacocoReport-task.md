# è¸©å‘æ—¥è®°ä¹‹Gradleç»“åˆJacocoReportè‡ªå®šä¹‰Test task

## èµ·å› 

æœ€è¿‘æ–°å†™äº†ä¸€ä¸ªé¡¹ç›®ï¼Œä¸ºäº†æ›´å¥½çš„ä¿è¯é¡¹ç›®è¾“å‡ºçš„è´¨é‡ï¼Œå¼•å…¥äº†å•å…ƒæµ‹è¯•è¦†ç›–ç‡ç»Ÿè®¡æ¡†æ¶`Jacoco`ã€‚ç”±äºgradleå®˜ç½‘ä¸Šçš„æ¡ˆä¾‹åªæœ‰å‡ ä¸ªé»˜è®¤çš„`task(testã€JacocoTestReportç­‰)`çš„è®¾ç½®ï¼Œè€Œæˆ‘å¸Œæœ›èƒ½å¤Ÿé¢å¤–ä¸ºä¸åŒçš„å±‚æä¾›å•ç‹¬çš„`test`ï¼Œä¹Ÿå°±å‘ç”Ÿäº†æ¥ä¸‹æ¥è¿™äº›æœ‰è¶£çš„äº‹å„¿ã€‚

## 1. ä¸ºä»€ä¹ˆ`JacocoTestReport`æ€»æ˜¯è¢«SKIPPED

é¦–å…ˆï¼Œæˆ‘å†™äº†ä¸€ä¸ªè‡ªå®šä¹‰çš„testã€‚å¹¶ä¸”é€šè¿‡å°†`finalizedBy`æŒ‡å®šä¸º`JacocoTestReport`æ¥è®©testæ‰§è¡Œå®Œæ¯•åè‡ªåŠ¨æ‰§è¡Œ`JacocoTestReport`ã€‚è‡ªå®šä¹‰testä»¥åŠ`JacocoTestReport` å¦‚ä¸‹ï¼š

```groovy
//è‡ªå®šä¹‰test
task serviceTest(type: Test) {
    useTestNG()
    useJUnitPlatform()

    finalizedBy jacocoTestReport

    jacoco {
        enabled = true
        //æŒ‡å®šåŸå§‹æ•°æ®æ–‡ä»¶ä½ç½®
        destinationFile = layout.buildDirectory.file("jacoco/${taskName}.exec").get().asFile
        includes = ['xxxservice']
        excludeClassLoaders = []
        includeNoLocationClasses = false
        sessionId = "<auto-generated value>"
        output = JacocoTaskExtension.Output.FILE
    }
}

jacocoTestReport {
    // tests are required to run before generating the report
    dependsOn serviceTest
		
    //æŒ‡å®šè¦†ç›–ç‡ç»Ÿè®¡æ•°æ®æ–‡ä»¶ã€‚
    executionData(layout.buildDirectory.file("jacoco/${serviceTest.name}.exec").get().asFile)

    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, include: ['xxxservice'])
        }))
    }
    reports {
        xml.required = false
        csv.required = false
        html.outputLocation = layout.buildDirectory.dir('jacocoReport')
    }
}
```

çœ‹èµ·æ¥ä¼¼ä¹æ²¡å•¥é—®é¢˜ï¼Œè¯¥åšçš„éƒ½åšäº†ã€‚ä½†æ˜¯æ‰§è¡Œçš„æ—¶å€™ç¨‹åºå´è·³è¿‡äº†jacocoTestReportã€‚å½“æ—¶ç‰¹åˆ«çº³é—·ï¼Œå°±å»ç½‘ä¸Šæäº†ä¸ª[é—®é¢˜](https://stackoverflow.com/questions/69164311/jacocotestreport-always-skipped/69177867#69177867)ã€‚æœ€ågradleå®˜æ–¹çš„å·¥ä½œäººå‘˜ç»™äº†ç­”å¤ï¼Œå¤§æ¦‚æ„æ€æ˜¯`executionData`å¯¹åº”çš„æ–‡ä»¶ä¸å­˜åœ¨ï¼Œåœ¨`jacocoTestReport`é‡ŒåŠ ä¸Š`onlyIf = {true}` å¯ä»¥ä¿è¯`jacocoTestReport`ä¼šæ‰§è¡Œï¼Œå¹¶ä¸”æ‰§è¡Œæœ€ç»ˆä¼šæŠ¥å‡ºtest.execæ–‡ä»¶ä¸å­˜åœ¨çš„é”™è¯¯ã€‚okï¼Œæœ‰æ–¹å‘äº†ï¼Œé‚£å°±ä¸€ä¸ªä¸€ä¸ªæ¥åˆ†æã€‚

## 2. `task`é‡Œçš„`onlyIf`

äº‹å®ä¸Šï¼Œ`onlyIf`å†³å®šäº†`task`æ˜¯å¦è¢«æ‰§è¡Œã€‚åŒæ—¶ï¼Œ`onlyIf`å¯ä»¥è®¾ç½®å¤šä¸ªè§„åˆ™åˆ¤æ–­ï¼Œå¦‚æœæ‰€æœ‰çš„è§„åˆ™åˆ¤æ–­éƒ½è¿”å›ä¸º`true`ï¼Œæ‰ä¼šæ‰§è¡Œ`task`ã€‚å¦åˆ™ï¼Œè·³è¿‡`task`ã€‚

### 2.1 `SkipOnlyIfTaskExecuter`

è®©æˆ‘ä»¬è¿›å…¥`SkipOnlyIfTaskExecuter`ä¸€æ¢ç©¶ç«Ÿï¼š

```java
public class SkipOnlyIfTaskExecuter implements TaskExecuter {
    @Override
    public TaskExecuterResult execute(TaskInternal task, TaskStateInternal state, TaskExecutionContext context) {
        boolean skip = !task.getOnlyIf().isSatisfiedBy(task);
				
        //è·³è¿‡task
        if (skip) {
            return TaskExecuterResult.WITHOUT_OUTPUTS;
        }
				
        //æ‰§è¡Œtask
        return executer.execute(task, state, context);
    }

    //éå†æ‰€æœ‰è§„åˆ™
    public boolean isSatisfiedBy(T object) {
        Spec<? super T>[] specs = getSpecsArray();
        for (Spec<? super T> spec : specs) {
            if (!spec.isSatisfiedBy(object)) {
                //åªè¦æœ‰ä¸€ä¸ªè§„åˆ™ä¸é€šè¿‡ï¼Œåˆ™è¿”å›false
                return false;
            }
        }
        return true;
    }
}
```

### 2.2 onlyIfç”¨æ³•

é‚£ä¹ˆï¼Œæˆ‘ä¹ˆæ€ä¹ˆä½¿ç”¨`onlyIf`å‘¢ï¼Ÿ

#### 2.2.1 è‡ªå®šä¹‰è§„åˆ™ä½œä¸ºå”¯ä¸€åˆ¤æ–­æ¡ä»¶

è¿™é‡Œç”¨`=`å³å¯ã€‚

```groovy
task foo{
	onlyIf = {true}
}
//æˆ–è€…
foo.onlyIf = {true}
```

è¿™é‡Œæˆ‘ä»¬å¯ä»¥ä»gradleæºç `AbstractTask#setOnlyIf` çœ‹å‡ºæ¥

```java
public abstract class AbstractTask implements TaskInternal, DynamicObjectAware {
    public void setOnlyIf(final Closure onlyIfClosure) {
        taskMutator.mutate("Task.setOnlyIf(Closure)", new Runnable() {
            @Override
            public void run() {
                //è®¾ç½®onlyIfClosureå¹¶è¦†ç›–åŸæœ‰çš„onlyIfSpec
                onlyIfSpec = createNewOnlyIfSpec().and(onlyIfClosure);
            }
        });
    }

    //åˆ›å»ºä¸€ä¸ªæ–°çš„é»˜è®¤è¿”å›ä¸ºtrueçš„element
    private AndSpec<Task> createNewOnlyIfSpec() {
        return new AndSpec<Task>(new Spec<Task>() {
            @Override
            public boolean isSatisfiedBy(Task element) {
                //è°ƒç”¨æ–¹: task.isSatisfiedBy(task)
                return element == AbstractTask.this && enabled;
            }
        });
    }
}
```

#### 2.2.2 è‡ªå®šä¹‰è§„åˆ™ä½œä¸ºæ¡ä»¶åˆ¤æ–­çš„ä¸€éƒ¨åˆ†

å»æ‰`=`å³å¯

```groovy
task foo{
	onlyIf {true}
}
//æˆ–è€…
foo.onlyIf {true}
```

æºç éƒ¨åˆ†ï¼š

```java
public abstract class AbstractTask implements TaskInternal, DynamicObjectAware {
    public void onlyIf(final Closure onlyIfClosure) {
        taskMutator.mutate("Task.onlyIf(Closure)", new Runnable() {
            @Override
            public void run() {
                //æ’å…¥
                onlyIfSpec = onlyIfSpec.and(onlyIfClosure);
            }
        });
    }
}
```

è¿™ç§æ–¹å¼å¯ä»¥æ–¹ä¾¿æˆ‘ä»¬å®šä¹‰å¤šä¸ª`onlyIf`å—ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥ä¿è¯ä¸ä¼šè¦†ç›–ç³»ç»Ÿé»˜è®¤çš„`onlyIf`ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬æ¥èŠèŠ`jacocoTestReport`é¢„ç½®çš„`onlyIf`

## 3. `jacocoTestReport`çš„`onlyIf`ä¸ºä»€ä¹ˆ"é»˜è®¤"æ˜¯`false`

ä»ä¸Šé¢çš„åˆ†æå¯çŸ¥`jacocoTestReport`ä¼šè¢«è·³è¿‡æ˜¾ç„¶æ˜¯`isSatisfiedBy`è¿”å›äº†falseã€‚è€Œæ­£å¸¸æƒ…å†µé€šè¿‡`createNewOnlyIfSpec()`åˆå§‹åŒ–çš„`spec`å…¶`isSatisfiedBy`è¿”å›çš„å¿…ç„¶æ˜¯trueã€‚æ‰€ä»¥ï¼Œè‚¯å®šæ˜¯ä»€ä¹ˆåœ°æ–¹æ·»åŠ äº†é¢å¤–çš„`spec`ã€‚æˆ‘ä»¬å…ˆçœ‹çœ‹`JacocoReport`è¿™ç§ç±»å‹çš„`Task`æ˜¯å¦‚ä½•åˆå§‹åŒ–çš„ï¼š

```java
/**
 *  JacocoReport extends JacocoReportBase
 *  JacocoReportBase extends AbstractTask
 */
public abstract class JacocoReportBase extends JacocoBase {

    public JacocoReportBase() {
        //æ·»åŠ spec
        onlyIf(new Spec<Task>() {
            @Override
            public boolean isSatisfiedBy(Task element) {
                return Iterables.any(getExecutionData(), new Predicate<File>() {
                    @Override
                    public boolean apply(File file) {
                        return file.exists();
                    }
                });
            }
        });
    }
}
```

å¯ä»¥çœ‹åˆ°ï¼Œ`JacocoReport`åœ¨åˆå§‹åŒ–æ—¶ä¼šæ·»åŠ ä¸€ä¸ªéªŒè¯è§„åˆ™ï¼Œå¦‚æœ`getExecutionData()`å¯¹åº”çš„æ–‡ä»¶éƒ½å­˜åœ¨ï¼Œåˆ™è¿”å›`true`ï¼Œå¦åˆ™è¿”å›`false` ã€‚é‚£ä¹ˆï¼Œ`onlyIf`"é»˜è®¤"ä¸º`false`ï¼Œæ˜¾ç„¶æ˜¯`getExecutionData()`è¿”å›çš„æ–‡ä»¶è·¯å¾„ä¸­æœ‰çš„æ–‡ä»¶ä¸å­˜åœ¨ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬ç ”ç©¶ä¸ºä»€ä¹ˆä¼šæœ‰æ–‡ä»¶ä¸å­˜åœ¨çš„é—®é¢˜ã€‚

## 4. `jacocoTestReport`çš„`executionData`ä¸ºä»€ä¹ˆä¼šé»˜è®¤åŒ…å«"test.exec"

ç»è¿‡ä¸Šè¿°åˆ†æï¼Œæˆ‘ä»¬çŸ¥é“åªè¦ä¸ºtaskè®¾ç½®`onlyIf={true}`ä¹‹åï¼Œtaskå°±å¿…ç„¶ä¼šæ‰§è¡Œã€‚é€šè¿‡æ·»åŠ onlyIf={true}ï¼Œ`jacocoTestReport`å¼€å§‹è¿è¡Œã€‚è¿™æ˜¯çªç„¶åˆå¾—åˆ°ä¸€ä¸ªé”™è¯¯ï¼š

```text
Unable to read execution data file /xxx/test.exec
```

å¾ˆå¥‡æ€ªï¼Œæ˜æ˜æˆ‘ä»¬è®¾ç½®çš„`executionData`æ˜¯`serviceTest.exec`ï¼Œä¸ºä»€ä¹ˆ`jacocoTestReport`ä¼šå»æŸ¥æ‰¾`test.exec`å‘¢ï¼Ÿæ˜¾ç„¶ï¼Œè¿™åˆæ˜¯è¢«é¢„ç½®çš„è¡Œä¸ºã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹çœ‹`jacocoTestReport`è¿™ä¸ª`Task`æ˜¯åœ¨å“ªé‡Œåˆ›å»ºå‡ºæ¥çš„ï¼š

```java
public class JavaPlugin implements Plugin<Project> {
		public static final String TEST_TASK_NAME = "test";
}

public class JacocoPlugin implements Plugin<Project> {

    private void addDefaultReportAndCoverageVerificationTasks(final JacocoPluginExtension extension) {
        project.getPlugins().withType(JavaPlugin.class, javaPlugin -> {

            //è·å–test Task
            TaskProvider<Task> testTaskProvider = project.getTasks().named(JavaPlugin.TEST_TASK_NAME);
            //åˆå§‹åŒ–jacocoTestReport Task
            addDefaultReportTask(extension, testTaskProvider);
        });
    }
		
    private void addDefaultReportTask(final JacocoPluginExtension extension, final TaskProvider<Task> testTaskProvider) {
        //testTaskNameæ˜¯å¸¸é‡test
        final String testTaskName = testTaskProvider.getName();
        //æ³¨å†ŒjacocoTestReport Task
        project.getTasks().register(
            "jacoco" + StringUtils.capitalize(testTaskName) + "Report",
            JacocoReport.class,
            reportTask -> {
                //å®šä¹‰è¯¥Taskçš„é»˜è®¤é…ç½®é¡¹
                //...
                //è®¾ç½®executionDataä¸ºtesté‡Œå®šä¹‰çš„destinationFile
                reportTask.executionData(testTaskProvider.get());
                //...
            });
    }
}

public abstract class JacocoReportBase extends JacocoBase {

    public void executionData(Task... tasks) {
        for (Task task : tasks) {
            //æ‹¿åˆ°ä¼ å…¥taské‡Œå®šä¹‰çš„jacoco extension,ä¹Ÿå°±æ˜¯jacoco{}å®šä¹‰çš„å†…å®¹
            final JacocoTaskExtension extension = task.getExtensions().findByType(JacocoTaskExtension.class);
            if (extension != null) {
                executionData(new Callable<File>() {
                    @Override
                    public File call() {
												//è®¾ç½®executionDataä¸ºtaské‡Œå®šä¹‰çš„destinationFile
                        return extension.getDestinationFile();
                    }
                });
                mustRunAfter(task);
            }
        }
    }
}
```

å¯ä»¥çœ‹åˆ°ï¼Œ`JacocoPlugin`åœ¨åˆå§‹åŒ–æ—¶ä¼šæ³¨å†Œä¸€ä¸ªç±»å‹ä¸º`JacocoReport`è€Œåç§°ä¸º`jacocoTestReport`çš„`Task`ï¼Œè¿™ä¸ª`Task`çš„`executionData`é»˜è®¤è®¾ç½®ä¸ºtest Taskçš„`jacoco extension`ä¸­å®šä¹‰çš„`destinationFile`ã€‚è€Œä¸Šæ–‡ä¸­çš„`test`çš„`jacoco extension`é‡Œå®šä¹‰çš„`destinationFile`æ­£å¥½æ˜¯`layout.buildDirectory.file("jacoco/${taskName}.exec").get().asFile`ã€‚æ‰€ä»¥åˆ°è¿™é‡Œå…¶å®ä¹Ÿå°±çœŸç›¸å¤§ç™½äº†ã€‚

äº‹å®ä¸Šï¼Œç±»å‹ä¸º`Test`çš„`Task`çš„`jacoco extension`çš„`destinationFile`é»˜è®¤å€¼å°±æ˜¯`layout.getBuildDirectory().file("jacoco/" + taskName + ".exec").map(RegularFile::getAsFile)`ã€‚æ‰€ä»¥ï¼Œå¦‚æœæˆ‘ä»¬æ²¡æœ‰å®šä¹‰è¿™ä¸ªå€¼ï¼Œä¹Ÿä¼šæŠ¥å‡ºåŒæ ·çš„é”™è¯¯ã€‚æºç éƒ¨åˆ†å¦‚ä¸‹ï¼š

```java
public class JacocoPlugin implements Plugin<Project> {
    public void apply(Project project) {
        JacocoPluginExtension extension = project.getExtensions().create(PLUGIN_EXTENSION_NAME, JacocoPluginExtension.class, project, agent);
        //ä¸ºtestè®¾ç½®é»˜è®¤jacoco extension
        applyToDefaultTasks(extension);
        //åˆå§‹åŒ–é»˜è®¤jacocoTestReport
        addDefaultReportAndCoverageVerificationTasks(extension);
    }

    private void applyToDefaultTasks(final JacocoPluginExtension extension) {
        //æ‹¿åˆ°æ‰€æœ‰test Taskå¹¶é…ç½®jacoco extension
        project.getTasks().withType(Test.class).configureEach(extension::applyTo);
    }
}

public class JacocoPluginExtension {
    public <T extends Task & JavaForkOptions> void applyTo(final T task) {
        final String taskName = task.getName();
        final JacocoTaskExtension extension = task.getExtensions().create(TASK_EXTENSION_NAME, JacocoTaskExtension.class, objects, agent, task);
        //è®¾ç½®æ–‡ä»¶åä¸º${taskName}.execã€‚test Taskå¯¹åº”çš„å°±æ˜¯test.exec
        extension.setDestinationFile(layout.getBuildDirectory().file("jacoco/" + taskName + ".exec").map(RegularFile::getAsFile));
    }
}
```

## 5. æ€ä¹ˆå®ç°æœ€åˆçš„ç›®æ ‡

æ—¢ç„¶æˆ‘ä»¬çŸ¥é“äº†`jacocoTestReport`é‡Œé¢„è®¾äº†`executionData`ï¼Œé‚£ä¹ˆè¦å®ç°æœ€åˆç›®æ ‡ï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨æ‰§è¡Œ`task`æ—¶æŠŠå®ƒæ¸…ç©ºå¹¶é‡æ–°è®¾ç½®ï¼Œæˆ–è€…è‡ªå®šä¹‰ä¸€ä¸ªå¹²å‡€çš„`JacocoReport`å³å¯ã€‚

### 5.1 æ¸…ç©ºå¹¶é‡æ–°è®¾ç½®

```groovy
jacocoTestReport {
    // tests are required to run before generating the report
    dependsOn serviceTest
		//æ¸…ç©ºé¢„è®¾çš„executionData
		((DefaultConfigurableFileCollection) executionData).filesWrapper.clear();
		//æŒ‡å®šè¦†ç›–ç‡ç»Ÿè®¡æ•°æ®æ–‡ä»¶ã€‚
		executionData(layout.buildDirectory.file("jacoco/${serviceTest.name}.exec").get().asFile)

    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, include: ['xxxservice'])
        }))
    }
    reports {
        xml.required = false
        csv.required = false
        html.outputLocation = layout.buildDirectory.dir('jacocoReport')
    }
}
```

### 5.2 è‡ªå®šä¹‰ä¸€ä¸ªå¹²å‡€çš„`JacocoReport`

```groovy
task jacocoServiceTestReport(type: JacocoReport) {
    // tests are required to run before generating the report
    dependsOn serviceTest

    //è‡ªå®šä¹‰çš„ä¸ä¼šåˆå§‹åŒ–æºç ç›®å½•ï¼Œéœ€è¦æ‰‹åŠ¨æŒ‡å®š
    sourceSets sourceSets.main

    executionData(layout.buildDirectory.file("jacoco/${serviceTest.name}.exec").get().asFile)

    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, include: project.ext.serviceSources)
        }))
    }
    reports {
        xml.required = false
        csv.required = false
        html.outputLocation = layout.buildDirectory.dir(project.ext.reportDir as String)
    }

    onlyIf = { true }
}
```

## æ€»ç»“

å› ä¸ºå¯¹`gradle`è·Ÿ`jacoco`ä¸æ€ä¹ˆç†Ÿï¼Œå½“æ—¶çœ‹åˆ°å”¯ä¸€çš„æç¤ºä¿¡æ¯ï¼š`jacocoTestReport SKIPPED`æˆ‘æ˜¯ä¸€è„¸æ‡µé€¼çš„ã€‚å¥½åœ¨å½“æ—¶ä»stackOverFlowä»¥åŠ[å®˜æ–¹](https://github.com/gradle/gradle/issues/18271)é‚£é‡Œå¾—åˆ°äº†ä¸€ä¸ªåˆ‡å…¥ç‚¹ï¼š`onlyIf={true}`ã€‚è®©é—®é¢˜æœ€ç»ˆå¾—ä»¥è§£å†³ã€‚

å¦ä¸€æ–¹é¢ï¼Œæˆ‘è§‰å¾—å®˜æ–¹åœ¨è¿™ä¸€å—çš„sampleç•¥æ˜¾ç®€é™‹ï¼Œè¿™äº›é»˜è®¤è¡Œä¸ºè‡³å°‘åº”è¯¥æä¸€ä¸‹ï¼Œå¦åˆ™å¾ˆå®¹æ˜“è®©äººæ‘¸ä¸ç€å¤´è„‘ã€‚æ‰€ä»¥æˆ‘ç¿»æ–‡æ¡£ç»ˆç©¶æ²¡æœ‰ç¿»å‡ºè§£å†³æ–¹æ¡ˆ(å¦‚æœæœ‰å“ªä½æœ‹å‹å‘ç°å®˜æ–¹æ–‡æ¡£æœ‰è¿‡è¿™æ–¹é¢çš„æè¿°ï¼Œæ¬¢è¿æŒ‡å‡ºğŸ‘)ã€‚